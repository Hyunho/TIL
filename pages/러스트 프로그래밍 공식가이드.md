- [[Rust]] 에 관한 책이다
	- 영문 링크 : https://doc.rust-lang.org/1.29.2/book/2018-edition/ch05-02-example-structs.html
- 챕터 1. 시작하기
	- **rustup** 러스트의 버전과 관련된 도구를 관리하는 명령줄 도구
		- 최신버전 업데이트
			- `rustup update`
		- rustup  도구 및 rust를 제거하려면
			- `rustup self uninstall`
		- 로컬에 설치된 문서를 보려면
			- `rustup doc`
	- 러스트 프로그램 기본 구조
		- ```fn main(){
		  
		  }
		  
		  ```
	- **rustfmt** 러스트의 자동 포매팅(formatting)
	- 러스트에서의 들여쓰기는 공백 문자 4개
	- **cargo** 러스트의 빌드 시스템이자 패키지 관리자
		- `cargo new hell_cargo` 명령을 사용해 새로운 프로젝트를 생성한다
			- cargo.toml
		- `cargo check` 라는 명령어를 사용해 컴파일 여부를 신속하게 검사할 수 있다.실팽파일을 생성되지 않는다.
		- `cargo build` 명령을 통해 빌드를 수행한다 .
			- `cargo build --release` 명령을 통해 최적화된 컴파일을 실행할 수 있다. 배포용으로 사용된다.
		- `cargo run`명령을 통해 프로젝트의 빌드와 실행을 한번에 해결한다.
	- 러스트
- 챕터 2. 숫자 맞히기 게임의 구현
	- Result 타입
		- 만일 `io::Result` 타입의 인스턴스가 Err 값이라면 expect 메서드는 프로그램을 종료하고 expect 메서드에 인수로 전달한 메시지를 표시한다.
		- `io::result`의 인스턴스 값이 Ok라면 expect 메서드는 Ok값이 보관하고 있는 값만을 읽어와 리턴한다.
	- 크레이트(crate)
		- 바이너리 크레이트(binary crate)
		- 라이프러리 크레이트(library crate)
	- 외부 크레이트를 업데이트하기 위해서는
		- `cargo update`명령을 사용한다. 이 명령은 cargo.toml 파일에 지정된 조건에 해당하는 가장 최신버전을 찾고 Cargo.lock 파일의 버전을 갱신한다.
	- 모든 의존 패키지가 제공하는 문서를 브라우저에서 보기 위해서는
		- `cargo doc —open`
- 챕터 3. 일반 프로그래밍 개념
	- 변수
		- 기본적으로 변경이 불가능하다.
		- 변경하고 싶을 경우에는 mut 키워드와 함께 사용한다 .
	- 상수
		- 항상 불변이다.
		- 대문자 + 밑줄 조합이다.  예시 : MAX_POINTS
	- 데이터 타입
		- 문자열을 숫자 타입으로 변환할 때처럼, 여러 타입을 사용할 수 있을 때는 다음처럼 ‘타입 애노테이션(annotation)’을 이용해 타입을 명시해 주어야 한다.
		- 데이터 타입의 두가지 부분 집합
			- 스칼라(Scalar)
				- 정수
				- 부동 소수점 숫자
				- 빌리언
				- 문자
			- 컴파운드(Compound)
				- 튜플
				- 배열
	- 함수
		- 함수와 변수의 이름에는 스네이크 케이스(snake_case)를 사용한다.
		- 함수 매개 변수
		- 함수 시그니처에는 각 매개변수의 타입을 명시해야 한다.
			- ```fn main() {
			      another_function(5);
			  }
			  
			  fn another_function(x: i32) {
			      println!("x의 값: {}", x)
			  }
			  ```
		- 함수 본문의 구문과 표현식
			- 러스트는 표현식 기반 언어여서 구문과 표현식을 구분하는 것은 매우중요하다.
			- 구문은 어떤 동작은 실행하지만 값을 리턴하지 않는 명령이다.
			- 반면, 표현식은 최종 결괏값으로 평가(evaluate)된다.
			- ```rust
			  fn main() {
			      let x = 5;
			  
			      let y = { // y의 값은 4
			    let x = 3;
			    x + 1 // 표현식
			      };
			  
			      println!("y의 값 {}", y);
			  }
			  ```
			- 함수는 자신을 호출한 코드에 값을 리턴할 수 있다. 리턴값에는 이름을 부여하지는 않지만 리턴할 값의 타입은 화살표(->)다음에 지정해줘야 한다.
			- 주석은 두 개의 슬래시(//)로 시작한다.
			- ```fn main() {
			      // 주석을 달기로 한다. 
			      let x = plus_one(5);
			      println!("x의 값: {}", x)
			  }
			  
			  fn plus_one(x: i32) -> i32 {
			      x + 1
			  }
			  ```
	- 흐름 제어
		- if 표현식
			- if 문의 조건은 반드시 불리언 타입 중 하나를 리턴해야 한다. 아래와 같은 경우는 에러가 발생된다.
				- ```fn main() {
				    let number = 3;
				    if number {
				      println!("변수의 저장된 값은 3입니다.");
				    }
				  }
				  ```
			- else if를 이용해 여러 조건을 처리할 수 있다. 다만 else if 표현식을 너무 많이 사용하면 코드가 지저분해 보이므로 둘 이상의 else if 표현이 필요할 때는 코드를 리팩토링 해야 한다. 이 때 match 표현식을 사용할 수 있다.
			- let 구문에서 if 표현식을 사용해 값을 대입할 수 있다. 다만 if 표현식을 이용해 반환될 수 있는 값들의 타입을 일치해야 한다.
				- ```let number = if condition {
				    5
				  } else {
				    6
				  }
				  ```
		- 루프를 이용한 반복
			- loop를 이용한 반복 실행을 할 수 있으며 루프안에 break 키워드를 삽입하여 루프의 실행을 중단시킬 수 있다. 또한 if문과 마찬가지로 let 구문과 함께 사용하여 값을 대입할 수도 있다.
				- ```fn main() {
				      let mut counter = 0;
				  
				      let result = loop {
				   counter += 1;
				   if counter == 10 {
				       break counter * 2;
				   }
				      };
				  
				      println!("The result is {}", result);
				  }
				  ```
			- 조건문의 평가 결과에 따라 루프를 실행해야 할 때에는 while 루프를 사용하는 것이 일반적이다.
			- 배열 같은 컬렉션의 각 요소를 반복 처리할 때에는 for 구문을 이용해 처리해야 코드의 안전성이 더 높으며, 배열의 길이를 잘못 지정해서 배열의 끝을 넘어서거나 일부 요소를 처리하지 못하는 버그를 사전에 방지할 수 있다.
			- for 로프는 그 안전성과 간결함때문에 러스트에서 가장 많이 사용된다. while루프를 사용해 카운트다운을 실행하는 일정 횟수만 반복하고자 할 때에도 for 루프를 사용하며 표준 라이브러리에 포함된 Range 타입을 이용한다. 아래의 예저와 같이 rev 메서드(reverse)를 혼합하여 사용할 수 있다.
				- ```fn main() {
				      for number in (1..4).rev() {
				   println!("{}", number);
				      }
				      println!("발사!");
				  }
				  ````
	- 과제
		- TODO 섭씨와 화씨 온도 변환기
		- TODO n번째 피보나치 만들기
- 챕터 4. 소유권
	- 소유권 규칙
		- 러스트가 다루는 다루는 각각의 값은 소유자(owner)라고 부르는 변수를 가지고 있다.
		- 특정 시점에 값의 소유자는 단 하나뿐이다.
		- 소유자가 범위를 벗어나면 그 값은 제거된다.
	- C++에서는 어떤 항목의 수명주기 마지막에 자원을 해제하는 패턴을 '초기화에 의한 자원 획득(RAII, Resource Acquisition Is Initialization)'이라고 부른다. 러스트의 drop 함수는 이 RAII 패턴과 유사하다.
	- 소유권을 유지하는 방법
		- 소유자 이동(move)
			- 흔히 얕은 복사(shallow copy)라고 불리는 기법은 여기서는 다르게 동작한다.
			- 얕은 복사가 일어나면서 기존의 변수는 무효화해버리므로 이 동작은 얕은 복사라고 하지 않고 이동(move)라고 한다. 이 예제의 경우 변수 s1이 변수 s2로 '이동했다'고 표현한다.
			- 소유권이 변수 s1에서 변수 s2로 이동한 것이다.
		- 복제
		- 복사
			- 만일 어떤 타입에 Copy 트레이트가 적용되어 있다면 이전 변수를 새 변수에 할당해도 무효화되지 않는다.
	- 함수
		- 함수 내에 인자를 전달할 경우에도 소유권의 변경이 일어날 수 있다.
		- 리턴 값도 소유권을 이전한다.
		- 함수내에 인자를 전달할 때 소유권을 대여할 수 있다. 이 소유권은 가져오지 않는 참조를 생성하여 이를 전달한다.
			- 참조는 소유권을 갖지 않기 때문에 참조가 가리키는 값은 참조가 범위를 벗어나더라도 drop함수가 호출되지 않는다.
	- 변수의 소유권은 매번 같은 패턴을 따른다. 즉, 값을 다른 변수에 할당하면 소유권이 옮겨진다. 힙 메모리에 저장된 변수의 데이터는 소유권이 다른 변수로 옮겨지지 않았다면 범위를 벗어날 때 drop 함수에 의해 제거된다.
	- 참조와 대여
		- 대여(borrowing) : 함수 매개변수로 참조를 전달하는 것이다. 실생활을 생각해보면 우리도 누군가의 소유물을 빌려쓰곤 한다. 그리고 사용이 끝나면 다시 되도록준다.
		- 불변 참조
			- 변수가 기본적으로 불변인 것처럼 참조도 기본적으로 불변이다. 따라서 참조하고 있는 값을 변경할 수 없다.
		- 가변 참조
			- &mut s 와 같이 변수에 mut 키워드를 추가하여 가변 참조를 생성할 수 있다.
			- 특정 범위 내의 특정 대이터에 대한 가변 참조는 오직 한개만 존재해야 한다.
				- ??? 다른 언어는 개발자가 원한다면 무엇이든 변경할 수 있기 때문에 가변 변수나 참조를 이용하는 부분은 러스트 개발자들이 가장 어려워 한다.
				- 이런 제약 덕분에 러스트트 데이터 경합(data races)을 컴파일 시점에 방지할 수 있다. 데이터 경협은 경합 조건(race condition)과 유사하며 주로 다음의 세가지 동작으로 인해 발생한.
					- 둘 혹은 그 이상의 포인터가 동시에 같은 데이터를 읽거나 쓰기 위해 접근할 때
					- 최소한 하나의 데이터가 데이터를 쓰기 위해 사용될 때
					- 데이터에 대한 접근을 동기화할 수 있는 메커니즘이 없을 때
				- 불볌 참조와 가변 참조를 섞어서 사용할 때도 비슷한 규칙이 적용된다. 즉 불변 참조를 이미 사용 중일 때에는 가변 참조를 생성할 수 없다. 단 불변 참조는 여러개 생성해도 무방하다.
		- 죽은 참조
			- 죽은 포인터란, 이미 해제되어 다른 정보를 저장하도록 변경된 메모리를 계속해서 참조하는 포인터를 말한다.
			- 러스트는 죽은 참조가 발생하지 않도록 컴파일러가 보장해 준다.
		- 참조에 대한 규칙
			- 어느 한 시점에 코드는 하나의 가변 참조 또는 여러 개의 불변 참조를 생성할 수 있지만, 둘 모두를 생성할 수는 없다.
			- 참조는 항상 유효해야 한다.
	- 슬라이스 타입
		- 슬라이스도 소유권을 갖지 않는 타입이다. 슬라이스를 이용하면 컬렉션 전체가 아니라 컬랙션 내의 연속된 요소들을 참조할 수 있다.